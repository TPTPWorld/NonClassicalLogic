From John.Halleck@utah.edu Mon May  2 13:33:15 2005
Return-path: <John.Halleck@utah.edu>
X-Original-To: geoff@sherman.cs.miami.edu
Delivered-To: geoff@sherman.cs.miami.edu
Received: from spitfire.math.miami.edu (spitfire.math.miami.edu [129.171.34.4])
	by sherman.cs.miami.edu (Postfix) with SMTP id 8DCA8AD29
	for <geoff@sherman.cs.miami.edu>; Mon,  2 May 2005 13:33:15 -0400 (EDT)
Received: (from root@localhost)
	by spitfire.math.miami.edu (8.12.8p1/8.12.8) id j42HXDw6012794
	for geoff@cs.miami.edu; Mon, 2 May 2005 13:33:13 -0400 (EDT)
	(envelope-from John.Halleck@utah.edu)
Received: from yoop.oz.cc.utah.edu (nahaj@yoop.oz.cc.utah.edu [155.99.2.5])
	by spitfire.math.miami.edu (8.12.8p1/8.12.8av) with ESMTP id j42HXA1r012784
	for <geoff@cs.miami.edu>; Mon, 2 May 2005 13:33:11 -0400 (EDT)
	(envelope-from John.Halleck@utah.edu)
Received: from localhost (nahaj@localhost)
	by yoop.oz.cc.utah.edu (8.9.2/8.9.2) with ESMTP id LAA11880;
	Mon, 2 May 2005 11:33:00 -0600 (MDT)
Date: Mon, 2 May 2005 11:32:59 -0600 (MDT)
From: John Halleck <John.Halleck@utah.edu>
Sender: John.Halleck@utah.edu
To: geoff@cs.miami.edu
cc: dmsimm90@hotmail.com, simmondsd@yahoo.com,
	daphne.simmonds@gkco.com, John Halleck <John.Halleck@utah.edu>
Subject: Comments on M from S1-0 + M10
In-Reply-To: <20050426134008.67BD2AE60@sherman.cs.miami.edu>
Message-ID: <Pine.GSO.4.05.10505011444350.29202-100000@yoop.oz.cc.utah.edu>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
X-Virus-Scanned: Trial by Fire
X-UID: 193
Status: ORr

On Tue, 26 Apr 2005 geoff@cs.miami.edu wrote:

> We can automatically prove axiom 5 from S1-0 + M10, but we are still
> struggling with proving axiom M (aka T). Have you had any progress

  Making the assumption that you mean M from S1-0 + M10

> with a proof of that? Thanks for any help!


  I've not succeeded in T or M, but I can easily derive the
  *RULE* equivalent to T.   I need to go hunt through references
  other than the set on my desk and see who's written on the proof.


  I'm still working on it...

================================================================

HOWever, I did finally get a proof in place that can get from
  S1-0 + M10 (Mp => LMp)
to            Mp  > LMp)
 
Although anything this long produced by me probably has at least minor errors.

I enclose it because some of the techniques *might* be interesting.
  I.E. maybe some of the items might be usefull lemmas.


Before you look at the proof, the text needs some explaination...

I have a library of [named] proof fragments, with some interdependency information.
And some (simple) utilities that can do some things with them.
Such as fix up the "Reason" part of the line to point to the lines that are named.
(Of course, this gives the wrong line if the wrong property was named...)

HOWEVER, none of the fragments have been mechanically checked.
The programs are, in fact, unaware of the actual lines of the proof fragments other
than hauling them around.  They haven't even been syntax checked.
(And every once in a while, line numbers within a block may be wrong, because the
fragment has it wrong.)

By the way they were formed one is assured that there are no forward references,
and that all refereced proof chunks have been included, but there are chunks included
that are never referenced later.


I freely admit that the names of some of these fragments are not the best... but this
is all the result of stuff "not ready for prime time" yet.

Just for reference, here is what a "raw" unprocessed proof fragment looks like:

.  ~M(~p&~q) <=> ~M(~p&~q)  : (ID <=>),  ~M(~p&~q)/p, US
.  ~M(~p&~q) <=> ~M(~q&~p)  : -1, (Comm &), SSE # [at rightmost &]
.  (~p => q) <=> (~q => p)  : -1, def of => # (applied once to each side.)
 = Modus Tollens for => with initial negation
 = MT ~ =>


Doing this has caused me to go back and fix some bugs and do cleanup.
I guess it is time for me to go back and add code to verify the fragments.
(And ommit the sections that have been included and never used.)

Alleged proofs:
================================= Alleged proofs =================================================


Rules:

  US   =rule  # Uniform substitution
  MP=> =rule  # Modus Ponens for =>
  SSE  =rule  # Substitution of strict equivalences

Operators:

   ~ =op Unary
   M =op Unary
   L =op Unary
   & =op Binary
   > =op Binary
  => =op Binary
 <=> =op Binary

Definitions:

 +   : a+b     =def ~(~a & ~b)             [or]
  => : a=>b    =def ~M(a & ~b)             [Strict implication]
   > : a  > b  =def ~ (a & ~b)             [Material implication]
 <=> : a <=> b =def ( (a => b) & (b => a)) [Strict equivalence]
 L   : L a     =def ~M~a                   [Necessity]

Axioms:

M1:  (p & q) => (q & p)
M2:  (p & q) => p
M3:  ((p & q) & r) => (p & (q & r))
M4:  p => (p & p)
M5:  ((p => q) & (q => r)) => (p => r)

# M10: Mp => LMp
#(Included at the very end)

Conventions:

  The usual operator precedence

===============  Goals: Generate 5

     Mp > LMp          (The same as M10, but with implication instead of strict implication.)

========================================================================
========================== Proof =======================================

Make M1 into an equivalence we can use anywhere.

   1.  (q & p)  => (p & q)                          : M1, q/p, p/q, US
   2. ((q & p)  => (p & q)) & ((p & q) => (q & p))  : M1, 1, Adjunction
   3.  (q & p) <=> (p & q)                          : 2, def of <=>
  = Commutivity for &
  = Comm &

   4.                     (p & p) => p   : M2, p/q, US
 = Reduction for p
 = Reduce p

Make M2 into an equivalence we can use anywhere.

   5. ( p  => (p & p) ) & (p & p) => p)  : M4, 4, Adjunction.
   6.   p <=> (p & p)                    : 5, def of <=>
 = Rendundancy for &
 = Redn &

And generate some axioms useful for any implicational system.

   7.       p  => p           : 4 (Reduce p), 6 (Redn &), SSE
 = Identity for =>
 = Id =>

   8.       p <=> p           : 6 (Redn &), 6 (Redn &), SSE
 = Identity for <=>
 = Id <=>

Make M3 into an equivalance we can use anywhere.

   9.  ((r & q) & p)  => (r & (q & p))                                      : M3, r/p, p/r, US
  10.  ((q & r) & p)  => (r & (p & q))                                      : 9, 3 (Comm &), SSE
  11.  (p & (q & r))  => ((p & q) & r)                                      : 10, 3 (Comm &), SSE
  12. ((p & (q & r))  => ((p & q) & r)) & (((p & q) & r) => (p & (q & r)))  : 11, M3, Adjunction.
  13.  (p & (q & r)) <=> ((p & q) & r)                                      : 12, def of <=>
 = Associtivity for &
 = Assot &


A Modus Tollens

  14.  ~M(~p&~q) <=> ~M(~p&~q)   : 8 (Id <=>), ~M(~p&~q)/p, US
  15.  ~M(~p&~q) <=> ~M(~q&~p)   : 14, 3 (Comm &), SSE
  16.  (~p => q) <=> (~q => p)   : 15, def of =>
 = Modus Tollens for => with initial negation
 = MT ~ =>

  17. (p <=> q) <=> (p <=> q)          : 8 (Id <=>), (p<=>q)/p, US
  18. (p <=> q) <=> ((p=>q) & (q=>p))  : 17, Def <=>
  19. (p <=> q) <=> ((q=>p) & (p=>q))  : 18, 3 (Comm &), SSE
  20. (p <=> q) <=> (q <=> p)          : 19, def <=>
 = Communitivity for <=>
 = Comm <=>

One half of double negation.

  21.   ( ~p => ~p) <=> (~~p => p)  : 16 (MT ~ =>), ~p/q, US
  22.   ( ~p => ~p)                 : 7 (Id =>), ~p/p, US
  23.   (~~p =>  p)                 : 22, 21, SSE
 = Reduction for ~
 = Reduce ~
                                 # [I.E. totally
                                 # replacing the line with it's equivalent]
                                 # Since we don't formally have MP for <=>,
                                 # This trick with SSE is often used, since it is
                                 # as short as MP<=> would be.

Intermediate double negation results.

  24.  (~~~~p => ~~p)                : 23 (Reduce ~), ~~p/p, US
  25.  (~~~~p => ~~p) && (~~p => p)  : 24, aa, Adjunction.
  26. ((~~~~p => ~~p) && (~~p => p)) => (~~~~p => p)  : M5, ~~~~p/p, ~~p/q, p/r, US
  27.                                   (~~~~p => p)  : 26, 25, MP=>
  28. (~~~~p => p) =>  (~p => ~~~p)  : 16 (MT ~ =>), ~ ~ ~ p/p, p/q, US
  29.                  (~p => ~~~p)  : 24, 28, MP=>
  30. (~~~p => ~p)                   : 23 (Reduce ~), ~p/p, US
  31. (~~~p => ~p)  &  (~p => ~~~p)  : 30, 29, Adjunction.
  32. (~~~p <=> ~p)                  : 31, def of <=>

And finally double negation.

  33. ~M(p&  ~p) =>   ~M(p&  ~p)  : 7 (Id =>), ~M(p&~p)/p, US
  34. ~M(p&  ~p) =>   ~M(p&~~~p)  : 33, 32, SSE [replacing rightmost ~p]
  35.   (p => p) =>  (p =>  ~~p)  : 34, def of =>
  36.                (p =>  ~~p)  : 7 (Id =>), 35, MP=>

  37. (~~p => p)  &  (p =>  ~~p)  : 23 (Reduce ~), 36, Adjunction.
  38. (~~p <=> p)                 : 37, Def of <=>
 = Double Negation
 = DN

Other flavors of Modus Tolens

.  (~~p => ~q) <=> (~~q => ~p) ; (MT ~ =>), ~p/p, ~q/q, US
.  (  p => ~q) <=> (  q => ~p) ; -1, DN, SSE
= Modus Tolens for => with final negation
= MT => ~

  39. (  p => ~~q) <=> ( ~q => ~p)  : 38 (MT => ~), ~q/q, US
  40. (  p =>   q) <=> ( ~q => ~p)  : 39, 38 (DN), SSE
 = Modus Tolens for =>
 = MT =>

  41. (~p <=> q) <=> ( ~p <=> q)                : 8 (Id <=>), (~p <=> q)/p, US
  42. (~p <=> q) <=> ( (~p => q) && ( q => ~p)  : 41, def <=>
  43. (~p <=> q) <=> ( (~q => p) && ( q => ~p)  : 42, 16 (MT ~ =>), SSE
  44. (~p <=> q) <=> ( (~q => p) && ( p => ~q)  : 43, 38 (MT => ~), SSE
  45. (~p <=> q) <=> ( ~q <=> p)                : 44, def <=>
 = Modus Tollens for <=> initial negation
 = MT ~ <=>

  46. (~~p<=>~q) <=> (~~q <=> ~p)   : 45 (MT ~ <=>), ~p/p, ~q/q, US
  47. (  p<=>~q) <=> (  q <=> ~p)   : 46, 38 (DN), SSE
 = Modus Tolens for <=> final negation
 = MT <=> ~


  48. (  p <=> ~~q) <=> ( ~q <=> ~p)  : 47 (MT <=> ~), ~q/q, US
  49. (  p <=>   q) <=> ( ~q <=> ~p)  : 48, 38 (DN), SSE
 = Modus Tolens for <=>
 = MT <=>

  50. ~(~p&~q) <=> ~(~p&~q)  : 8 (Id <=>), ~(~p&~q)/p, US
  51. ~(~p&~q) <=> ~(~q&~p)  : 50, 3 (Comm &), SSE
  52.  (~p >q) <=>  (~q >p)  : 51, Def >
 = Modus Tollens for >, initial ~
 = MT ~ >

  53. (~~p>~q) <=> (~~q>~p)  : 52 (MT ~ >), ~p/p, ~q/q, US
  54. (  p>~q) <=> (  q>~p)  : 53, DN, SSE
 = Modus Tollens for >, final ~
 = MT > ~

  55. (~~p > q) <=> ( ~q > ~p)  : 52 (MT ~ >), ~p/p, US
  56. (  p > q) <=> ( ~q > ~p)  : 55, DN, SSE
 = Modus Tollens for >
 = MT >

  57. (  p <=>   q) <=> ( ~p <=> ~q)  : 49 (MT <=>), 20 (Comm <=>), SSE
 = Negation equivalence
 = Neg <=>

  58.   (~q&~p) <=>  (~p&~q)  : M1, ~q/p, ~p/q, US
  59.  ~(~q&~p) <=> ~(~p&~q)  : 58, 49 (MT <=>)
  60.    (q+p)  <=>  ( p+ q)  : 59, def +
 = Communitivity for +
 = Comm +


Define M in terms of L

  61.  ~ L ~p <=> ~L~p  : 8 (Id <=>), ~L~p/p, US
  62.  ~~M~~p <=> ~L~p  : 61, def L
  63.    M  p <=> ~L~p  : 62, 38 (DN), SSE
 = Redefinition of M
 = Redef M

Transformation based on Duality of M and L

  64. L~p <=>  L  ~p  : 8 (Id <=>), Lp/p, US
  65. L~p <=> ~M~ ~p  : 64, def L
  66. L~p <=> ~M   p  : 65, 38 (DN), SSE
 = Push ~M

  67. ~Lp <=> ~ L p  : 8 (Id <=>), ~Lp/p, US
  68. ~Lp <=> ~~M~p  : 67, Def L
  69. ~Lp <=>   M~p  : 68, 38 (DN), SSE
 = Push ~L

Define => in terms of L and >

  70.   (p=>q) <=>   (p=>q)  : 8 (Id <=>), (p=>q)/q, US
  71.   (p=>q) <=> ~M(p&~q)  : 70, def =>
  72.   (p=>q) <=> L~(p&~q)  : 71, 66 (Push ~M), SSE
  73.   (p=>q) <=> L (p >q)  : 72, def >
 = Redefinition of =>
 = Redef =>

  74.     (p=>q) <=> L~ (~~p&~q)  : 72, 38 (DN)
  75.     (p=>q) <=> L  ( ~p+ q)  : 74, def +

  76. ( p& p) <=>  p        : 6 (Redn &), 20 (Comm <=>), SSE
  77. (~p&~p) <=> ~p        : 76, ~p/p, US
  78. ~~p     <=> ~(~p&~p)  : 77, MT <=>
  79. ~~p     <=>  ( p+ p)  : 78, def +
  80.   p     <=>  ( p+ p)  : 79, 38 (DN)
 = Redundancy for +
 = Redn +

  81. ( M~p <=> M~q) <=> (~M~q <=> ~M~p) : 49 (MT <=>), M~q/p, M~q/q, US
  82. ( M~p <=> M~q) <=> ( L q <=>  L p) : 81, def L
  83. ( M~p <=> M~q) <=> ( L p <=>  L q) : 82, 20 (Comm <=>), SSE
  84. ( L p <=> L q) <=> ( M~p <=>  M~q) : 83, 20 (Comm <=>), SSE

  85. ( M~~p => M~~q) <=> ( L~q => L~p)  : -1. ~p/p, ~q/q, US
  86. ( M  p => M  q) <=> ( L~q => L~p)  : 85, 38 (DN), SSE
  87. ( M  p => M  q) <=> ( L~p => L~q)  : 86, 20 (Comm <=>), SSE


General "this in terms of that" ...

  88.  p <=> ~~(p&  p)    : 6 (Redn &), 38 (DN), SSE
  89.  p <=> ~~(p&~~p)  : 88, 38 (DN), SSE
  90.  p <=> ~ (p >~p)  : 89, def >
= negative p equivalence
= ~p equiv

  91. ~p     <=> ~~(~p&~~~p)  : 89, ~p/p, US
  92. ~p     <=> ~~(~p&  ~p)  : 91, 38 (DN), SSE
  93. ~p     <=>  ~(~p > p)   : 92, def >
  94. (~p>p) <=>       p      : 93, 45 (MT ~ <=>), SSE
  95. p      <=>     (~p>p)   : 94, 20 (Comm <=>), SSE
= p equivalence
= p equiv

  96. ~( p > ~p) <=> (~p >  p)  : 95, 90 (~p equiv), SSE
  97. ~(~p >  p) <=> ( p > ~p)  : 96, 45 (MT ~ <=>), SSE

  98. ~ (p > q) <=> ~ (p > q)  : Identity <=>, ~(p>q)/p, US
  99. ~ (p > q) <=> ~~(p &~q)  : 98, Def >
 100. ~ (p > q) <=>   (p &~q)  : 99, DN, SSE
= ~ converson

And the equivalent strict versions.

 101. Lp <=> Lp        : 8 (Id <=>), Lp/p, US
 102. Lp <=> L(~p >p)  : 101, 95 (p equiv), SSE
 103. Lp <=>  (~p=>p)  : 102, 73 (Redef =>), SSE
= L equivalence
= L equiv

 104. Lp <=> L~(p > ~p)  : 101, 90 (~p equiv), SSE
 105. Lp <=> ~M(p > ~p)  : 104, 66 (Push ~M), SSE

 106. Mp <=>   M  p      : 8 (Id <=>), Mp/p, US
 107. Mp <=>   M(p&  p)  : 106, 6 (Redn &), SSE
 108. Mp <=> ~~M(p&  p)  : 107, 38 (DN), SSE
 109. Mp <=> ~~M(p&~~p)  : 108, 38 (DN), SSE
 110. Mp <=> ~  (p=>~p)  : 109, Def =>
= M equivalence
= M equiv

    # Note that          we have ~(p >~p) <=> (~p >p) .
    # but we *** DON'T ***  have ~(p=>~p) <=> (~p=>p) .

Useful identity.

 111. ~M((p&q) & ~r) <=>  ~M((p & q)  &  ~r )  : 8 (Id <=>), ~M((p&q)&~r)/p, US
 112. ~M((p&q) & ~r) <=>  ~M( p &(q   &  ~r))  : 111, 13 (Assot &), SSE
 113. ~M((p&q) & ~r) <=>  ~M( p &(~r  &   q))  : 112, 3 (Comm &), SSE
 114. ~M((p&q) & ~r) <=>  ~M((p & ~r) &   q )  : 113, 13 (Assot &), SSE
 115. ~M((p&q) & ~r) <=>  ~M((p & ~r) &  ~~q)  : 114, 38 (DN), SSE
 116.   ((p&q)=>  r) <=>    ((p & ~r) =>  ~q)  : 115, Def of =>
 = Importation exportation & =>
 = Import & =>

 117. (~ r => ~(p& q) <=> ( ~ q => ~(p&~~r))  : 116 (Import & =>), MT =>, SSE
 118. (~~r => ~(p&~q) <=> ( ~~q => ~(p&~~r))  : 116 (Import & =>), MT =>, SSE
 119. (  r => ~(p& q) <=> (   q =>  (p> ~r))  : 118, Def >

 120.   (~ r => ~(p& q)) <=>   ((p & ~ r) => ~ q)  : 116 (Import & =>), 40 (MT =>), SSE
 121.   (~~p => ~(q&~r)) <=>   ((q & ~~p) => ~~r)  : 120, ~p/r, q/p, ~r/q, US
 122.   (  p => ~(q&~r)) <=>   ((q &   p) =>   r)  : 121, DN, SSE
 123.   (  p =>  (q> r)) <=>   ((q &   p) =>   r)  : 122, DEF >
 124.   (  p =>  (q> r)) <=>   ((p &   q) =>   r)  : 123, 3 (Comm &), SSE
 = Interchange of implication and &
 = Inter => >  &

 125.   ((p&q)=> p) <=> ((p& ~p) => ~q)  : 116 (Import & =>), p/r, US
 126.   (p&~p) => q                            : M2, 125, SSE
= contradition for strict implication
= Contra =>

 127.   ((p&q)=>  r)    <=> ( ~~q => ~(p & ~r) )  : 116 (Import & =>), 38 (MT => ~), SSE
 128.   ((p&q)=>  r)    <=> (   q => ~(p & ~r) )  : 127, DN, SSE
 129.   ((p&q)=>  r)    <=> (   q =>  (p >  r) )  : 128,  (Def >), SSE
 130.   ((q&p)=>  r)    <=> (   q =>  (p >  r) )  : 129, 3 (Comm &), SSE
 131.   ((p&q)=>  r)    <=> (   p =>  (q >  r) )  : 130, q/p, p/q, US
 132.   (p => (q >  r)) <=> (   q =>  (p >  r) )  : 129, 131, SSE
= Importation exportation  => >
= Import => >

 133. (p>q) => (  p     > q)  : ID =>, (p>q)/p, US
 134.   p   => ((p>q)   > q)  : 133, Import => >, SSE
 135. ( p    &  (p>q)) => q   : 134, Inter => > &, SSE
= Axiom of Modes Ponens for >
= Axiom MP >

 136. (p > (p > q)) <=>  ( p >  (p  >  q))  : Identity <=>, (p > (p > q))/p
 137. (p > (p > q)) <=>  ( p > ~(p  &~ q))  : 136, def >
 138. (p > (p > q)) <=> ~( p &~~(p  &~ q))  : 137, def >
 139. (p > (p > q)) <=> ~( p &  (p  &~ q))  : 138, DN, SSE
 140. (p > (p > q)) <=> ~((p &   p) &~ q )  : 139, Comm &, SSE
 141. (p > (p > q)) <=> ~(   p      &~ q )  : 140, Redn &, SSE
 142. (p > (p > q)) <=>  (   p      >  q )  : 141, Def >
= Redundancy for >
= Redn >

 143. ((p> q) > q) <=>  ((p>q) >        q    )  : Identity <=>, ((p>q) > q), US
 144. ((p> q) > q) <=>  ( ~q   > ~ (p   >  q))  : 143, MT >, SSE
 145. ((p> q) > q) <=>  ( ~q   & ~~(p   & ~q))  : 144, Def >
 146. ((p> q) > q) <=> ~( ~q   &   (p   & ~q))  : 145, Def >
 147. ((p> q) > q) <=> ~( ~q   &   (~q  &  p))  : 146, Comm &, SSE
 148. ((p> q) > q) <=> ~((~q   &    ~q) &  p))  : 147, Assot &, SSE
 149. ((p> q) > q) <=> ~(     ~q        &  p))  : 148, Redn &, SSE
 150. ((p> q) > q) <=> ~(      p        & ~q))  : 149, Comm &, SSE
 151. ((p> q) > q) <=>  (      p        >  q))  : 150, def >
= Repitition for >
= Rep >

 152. (p => q) =>  ((q => r) > (p => r))  : M5, Inter => > &
= Consistancy of conclusions.
= Cons conc

 153. (r => p) =>  ((p => q) > (r => q))  : 152, r/p, p/q, q/r, US
 154. (p => q) =>  ((r => p) > (r => q))  : 153, Import => >, SSE
= Consistancy of premises
= Cons prem

 155. (p>(q>r)) <=>  ( p>  (q > r))  : 8 (Id <=>), (p>(q>r))/p, US
 156. (p>(q>r)) <=>  ( p> ~(q &~r))  : 155, Def >
 157. (p>(q>r)) <=> ~( p&~~(q &~r))  : 156, Def >
 158. (p>(q>r)) <=> ~( p&  (q &~r))  : 157, DN, SSE
 159. (p>(q>r)) <=> ~((p&   q)&~r))  : 158, 13 (Assot &), SSE
 160. (p>(q>r)) <=> ~((q&   p)&~r))  : 159, 3 (Comm &), SSE
 161. (p>(q>r)) <=> ~( q&  (p &~r))  : 160, 13 (Assot &), SSE
 162. (p>(q>r)) <=> ~( q&~~(p &~r))  : 161, DN, SSE
 163. (p>(q>r)) <=> ~( q&~ (p > r))  : 162, DEF >
 164. (p>(q>r)) <=>  ( q > (p > r))  : 163, DEF >
= Importation exportation > >
= Import > >

 165.  (~p&q) => ~p        : M2, ~p/p, US
 166.  ~~p     => ~(~p&q)  : 165, MT =>, SSE
 167.    p     => ~(~p&q)  : 166, DN, SSE
 168.    p     => ~(q&~p)  : 167, COMM &, SSE
 169.    p     =>  (q> p)  : 168, DEF >
= Truth strictly implies everything implies truth.
= Truth implication

 170.    q     => (p>p)  : 169 (Truth implication), Import => >, SSE
= Everything strictly implies material identity.
= identity implication


 171.                                 (p=>r) => ((r=>s)>(p=>s))                                          : cons conc, p/p, r/q, s/r
 172.   (((p=>q)&(q=>r)) => (p=>r)) &((p=>r) => ((r=>s)>(p=>s))                                          : M5, 171, Adjunction
 173.  ((((p=>q)&(q=>r)) => (p=>r)) &((p=>r) => ((r=>s)>(p=>s))) > (((p=>q)&(q=>r)) => ((r=>s)>(p=>s)))  : M5, ((p=>q)&(q=>r))/p, (p=>r)/q, ((r=>s)>(p=>s))/r, US
 174.                                                               ((p=>q)&(q=>r)) => ((r=>s)>(p=>s))   : MP =>

 175.    ((~q=>~p) &    (~p=>p)) => ((p=>q) > (~q=>q))     : 174, ~q/p, ~p/q, p/r, q/s, US
 176.     (~q=>~p) => ( (~p=>p)   > ((p=>q) > (~q=>q)) )   : 175, Inter => > &, SSE
 177.     ( p=> q) => ( (~p=>p)   > ((p=>q) > (~q=>q)) )   : 176, MT =>, SSE
 178.     ( p=> q) => (    Lp     > ((p=>q) >    Lq  ) )   : 177, L equiv, SSE
 179.         Lp   => ( ((p=>q)   > ((p=>q) >    Lq  ) )   : 178, Import => >, SSE
 180.         Lp   => (              (p=>q) >    Lq    )   : 179, Redn >, SSE
 181.       (p=>q) => (                Lp   >    Lq    )   : 180, Import => >, SSE
= L inheritance.
 182.      L(p >q) => (                Lp   >    Lq    )   : 181, Redef =>, SSE
= L distribution over >
= Dist L over >

 183.  (p => (q>p)) => ( Lp > L(q>p))  : L inheritance, p/p, (q>p)/q, US
 184.                    Lp > L(q>p)   : truth implication, 183, MP =>
 185.                    Lp >  (q=>p)  : 184, Redef =>, SSE
= Necessity implication
= L imp

 186.  Lp > ( Lp => p)  : L imp, Lp/q
= Lp imp

 187.  (Lp>p) =>  (Lp        > p )  : ID =>, (Lp>p)/p, US
 188. ((Lp>p) &    Lp     ) => p    : 187, Inter => > &, SSE
 189. (  Lp   &  (Lp>p)   ) => p    : 188, 3 (Comm &), SSE
= Axiom MP Lp
 190.    Lp  => ((Lp>p)      > p)   : Inter => > &, SSE
 191.    L(p>q) => ((L(p>q)>(p>q))>(p>q))  : 190, (p>q)/p, US

 192. L(p>q) > (L(p>q) => (p>q))  : Lp imp, (p>q)/p, US
= L reduction


 193.  L( L(p>q)>(Lp>Lq) )                                                                   : Dist L over >, redef =>, SSE
 194.                         L(L(p>q)>(Lp>Lq)) > (L(L(p>q)>(Lp>Lq)) => (L(p>q)>(Lp>Lq)))    : L reduction, L(p>q)/p, (Lp>Lq)/p, US
 195.  L( L(p>q)>(Lp>Lq) ) & (L(L(p>q)>(Lp>Lq))) > (L(L(p>q)>(Lp>Lq)) => (L(p>q)>(Lp>Lq)))   : 194, 193, Adjunction
 196. (L( L(p>q)>(Lp>Lq) ) & (L(L(p>q)>(Lp>Lq))) > (L(L(p>q)>(Lp>Lq)) => (L(p>q)>(Lp>Lq)))) => (L(L(p>q)>(Lp>Lq)) => (L(p>q)>(Lp>Lq)))  : Axiom MP >, L( L(p>q)>(Lp>Lq) )/p, (L(L(p>q)>(Lp>Lq)) => (L(p>q)>(Lp>Lq)))/q, US
 197. L(p>q)>(Lp>Lq)))) => (L(L(p>q)>(Lp>Lq)) => (L(p>q)>(Lp>Lq)))  : 196, 195, MP =>
 198.                       L(L(p>q)>(Lp>Lq)) => (L(p>q)>(Lp>Lq))   : 193, 197, MP =>
 199.                                             L(p>q)>(Lp>Lq))   : 193, 198, MP =>


-----------------  Introduction of M10 -------------------

M10: Mp => LMp

# Original goal:  Mp > LMp

 200. (Mp => LMp) => ( LMp > LLMp )  : L inheritance, Mp/p, LMp/q, US
 201.                  LMp > LLMp    : 200, M10, MP =>

 202.   M p => ~M~Mp  : M10, Def of L
 203. M~M p => ~M p   : 202, 38 (MT => ~), SSE
 204. M~M~p => ~M~p   : 203, ~p/p, US
 205. M L p =>  L p   : 204, Def of L
= Dual of M10
= M10 dual

 206.  L(Mp>LMp)                                                                  : M10, Redef =>, SSE
 207.               L(Mp>LMp) > (L(Mp>LMp)=>(Mp>LMp))                             : L imp, (Mp>LMp)/p, L(Mp>LMp)/q, US
 208.  L(Mp>LMp) & (L(Mp>LMp) > (L(Mp>LMp)=>(Mp>LMp))                             : 207, 206, Adjunction.
 209. (L(Mp>LMp) & (L(Mp>LMp) > (L(Mp>LMp)=>(Mp>LMp))) => (L(Mp>LMp)=>(Mp>LMp)))  : Axiom Mp >, L(Mp>LMp)/p, (L(Mp>LMp)=>(Mp>LMp)))/q, US
 210.                                                      L(Mp>LMp)=>(Mp>LMp)    : 209, 208, MP =>
 211.                                                                  Mp>LMp     : 206, 210, MP =>

# Q.E.D



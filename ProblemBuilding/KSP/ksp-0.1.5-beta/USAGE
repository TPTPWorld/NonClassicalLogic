KSP - Copyright (c) (2015-2021) Cláudia Nalon

1. RUNNING KSP

Usage: ./ksp [options] [-i file | -f "formula"]

Options:

Prover modes: KSP performs either local (-l option) or global (-g option) reasoning. The default is local reasoning. If using the configuration files, use set(local) and set(global) for those different modes, respectively.

Input modes: the input is read from either a file (-i option) or from the command line (-f option). Configuration files can also be given, using the option -c file. Options given at the command line override those in the configuration file.

Verbose modes: there are several levels of verbosity. If you do not specify the verbosity, then the prover runs quietly and prints if the input is satisfiable or unsatisfiable. Each level of verbosity adds the following:

-v 1: prints very short statistics of a particular run. 
-v 2: prints short statistics of a particular run.
-v 3: prints the phases of a particular run.
-v 4: prints statistics for each phase.
-v 5: prints the sets of clauses at the end of each phase.
-v 6: prints the symbol table at the end of each phase.
-v 7: prints the syntactic trees at the end of each phase.

Additionally, the following options can be used to control the output:

-pgen: prints the generated clauses
-pdel: prints the clauses being deleted
-pproof: prints all the proof(s) at the end of a run
-pren: prints the renaming table used in the top down renaming procedure
-pkept: prints the kept clauses at the end of the processing cycle
-pproofsize: prints the size of a proof
-pproofmaxlevel: prints the maximal modal level in a proof
-plevels: prints the number of levels
-pnumclauses: prints the number of clauses

The number of proofs is controlled by the following flag:

-maxproof n, where n is an integer

The default is 1. In the configuration file, you can use set(maxproof,n).

Literal selection: the following options are available:

-sat: saturation
-ord: ordered resolution
-neg: negative resolution
-pos: positive resolution

The default is sat.

Clause selection: the following options are available:

-short: chooses the shortest clause.
-old: chooses the oldest clause.
-new: chooses the newest clause.
-greatest: chooses the clause with the highest maximal literal in the clause set.
-smallest: chooses the clause with the lowest maximal literal in the clause set.

The default is short.

Modal level selection: these options control how the levels are scanned.

-ordlevel_ascend: ascending order of modal levels, that is, from ml = 0 to the maximal modal level. 
-ordlevel_descend: the modal levels are scanned from the maximal modal level down to ml = 0. 
-ordlevel_shuffle: the list of modal levels is partitioned in half and the two lists are merged, just before entering the inner loop; the modal levels are then scanned in the resulting order.

The default is none.

Redundancy elimination: by default, the prover only performs tautology elimination and repetition check within the sos. The following options can also be used:

-ple: global pure literal elimination, which is applied after transformation into clausal form.
-mlple: modal level pure literal elimination by modal level, which is applied after the transformation into clausal form.
-early_ple: performs global pure literal elimination prior to the transformation into the normal form.
-early_mlple: performs modal level pure literal elimination prior to the transformation into the normal form.
-mle: if the last level is saturated, then the whole level is deleted. 
-satmle: if no resolution step can be further applied to a particular modal level and a contradiction was not found at that modal level, then the set of modal clauses is satisfiable. This option removes the modal levels where this situation occurs.

-full_check_repeated: checks if the generated clause is in the usable.

-fsub: performs forward subsumption of the chosen clause against those in the usable set.
-bsub: performs backward subsumption of the chosen clause against those in the usable set.
-sos_sub: also performs subsumption against clauses in the sos.


Normal forms and their preprocessing: by default, the prover generates the SNF of the input, using normal renaming (i.e. a la Teitsin: one new variable for each subformula/position being renamed). The transformation function is that given in [1], for local reasoning with levels, or [2], for the transformation that renames within the universal operator. Other options are also available:

-cnf: it uses the distribution rule, instead of renaming conjunctions that occur in disjunctions.
-small_cnf: it does renaming only when there is some benefit; otherwise applies distribution in order to generate the normal form (this is not fully implemented yet).

-global2local: uses the transformation function given in [3]. Note that this generates more clauses than the transformation in [1], because conjuncts are renamed before rewriting is applied. This is intended for logics that extend K (see below).
-normal_renaming: one new variable for each subformula being renamed.
-limited_reuse_renaming: one new variable for all occurrences of each subformula being renamed.
-extensive_reuse_renaming: one new variable for all occurrences of each subformula being renamed; also, if a formula "phi" was renamed by a new variable "p", then the NNF of "not phi" is renamed by "not p".
-conjunct_renaming: it renames modal subformulae that occurs in conjunctions.

-snf+: renames negative literals in the scope of modal operators by positive literals. Completeness of negative resolution depends on setting this option.
-snf-: renames positive literals in the scope of modal operators by negative literals. Completeness of positive resolution depends on setting this option.
-snf++: renames all literals in the scope of modal operators by positive literals. Completeness of negative ordered resolution depends on setting this option.
-snf--: renames all literals in the scope of modal operators by negative literals. Completeness of positive ordered resolution depends on setting this option.

-aprenex: produces the antiprenex normal form of the input (i.e. it moves modal operators inwards).
-prenex: produces the prenex normal form of the input (i.e. it moves modal operators outwards).

-nnfsimp: it performs simplification over the NNF of the input. Note that this is not default.
-bnfsimp: it performs simplification over the BNF of the input. If this option is set, then nnfsimp is also performed.

Populating the usable: the prover can automatically populate the usable by selecting specific sets of clauses. Note that this is done after the preprocessing of clauses. By default, the usable is not populated.

-populate_non_negative: moves all non-negative literal clauses to the usable.
-populate_non_positive: moves all non-positive literal clauses to the usable.
-populate_negative: moves all negative literal clauses to the usable.
-populate_positive: moves all positive literal clauses to the usable.
-populate_max_lit_negative: moves all clauses whose maximal literal is negative to the usable.
-populate_max_lit_positive: moves all clauses whose maximal literal is positive to the usable.

Controlling the execution: the following options finish the execution of the prover at earlier stages:

-ppi_only: stops just after processing the input.
-snf_only: stops just after generating the clause sets.
-snf_plus_only: stops after extending the clause sets by a chosen normal form.
-pp_only: stops just after preprocessing the clauses, i.e. before entering the main loop.

Inference Rules: besides the inference rules given in [1], the following inference rules are also implemented:

-ires: implements initial resolution. If both -ires and -g (global) are set, the prover uses the calculus given in [2].
-unit: unit resolution is applied to literal clauses and to the right-hand side of modal clauses.
-lhs_unit: unit resolution is applied to the left-hand side of modal clauses (note that this is turned off for the calculus given in [2], as it is not sound).
-mres: this inference rule can only be applied if the clauses are in SNF. However, if this option is set, the inference rule is applied to the modal clauses prior to their transformation in an extended normal form (snf+, snf++, etc.).
-gen2: this inference rule can only be applied if the clauses are in SNF. However, if this option is set, the inference rule is applied to the modal clauses prior to their transformation in an extended normal form (snf+, snf++, etc.).
-propdia: this is a propagation rule for negative modal clauses. It can only be applied if there is exactly one of such clauses in a given modal level (otherwise, this is not sound).

Inference Rules for extensions of K:

- Using the inference rules given in [2]. The prover was extended to deal with extensions of K with the following axioms: D,B,T,4, and 5. You need to use the configuration files to bind the modal operator to the rules you wish to use. For instance, having

set(box,REF,SYM).

in the configuration file will set the prover to use the respective rules for T and B, given in [2]. As mentioned above, for this calculus you need to set the prover to global reasoning and also set on the ires rule.

- Using the local transformations given in [3]. Only one of the following axioms is allowed: D, B, T, 4, and 5. You can keep the default configurations and add

"-global2local"

to the command line or

set(global2local).

in the configuration file. You need to use the configuration files to set the particular logic for which the transformations are based, that is, there no corresponding switches for the command line. Examples of such files can be found within the conf.files/ijcar-2022 folder in this distribution.

Together with global2local, you can set a level of the tree up to which clauses will be generated. This is may result in an incomplete procedure. To set the height of the tree, i.e. the number of levels, you can use the following switch at the command line:

-mlbound <integer>


2 - SYNTAX and EXAMPLES

Syntax is not case sensitive ("p" and "P" are regarded as the same symbol). The following table gives the symbols that can be used for each operator:

PROPOSITIONAL SYMBOLS: an alphanumeric sequence starting with a letter: p, p1, p_1 (underscore should not be used at the beginning of a name)
CONSTANTS: true, false
NOT: -, ~, not
AND: &, and
OR: |, or
IMPLICATION: ->, =>, then
ONLY IF: <-, <=
DOUBLE IMPLICATION: <->, <=>, ifonlyif
BOX: box index, [index]
DIAMOND: dia index, <index>

The indexes are alphanumeric sequences starting with a letter or numbers, and are optional. Note that [] is just an abbreviation for [1]. Also note that modal operators are referred by their index, thus we have that box 1 = box = [] = [1].

Some examples:

./ksp -fsub -f "~(box p & box q -> box (p & q))"

produces as output "Unsatisfiable". If you want to see the proof, try:

./ksp -fsub -f "~([] p & [] q -> [] (p & q))" -pproof

The following, using global reasoning:

./ksp -fsub -f "~(p & box q -> box (p & q))" -pproof -g

produces "Unsatisfiable". But, with the local option,

./ksp -fsub -f "~(p & box q -> box (p & q))" -pgen -l

we obtain that the formula is satisfiable.

Some configuration and example files are provided with the prover. See the examples and the conf.files directories. One example of usage:

./ksp -c conf.files/cord.conf -i examples/K/ex001.p.ksp -pproof

shows the proof that "~ (box (p and q) imp (box p and box q))" is unsatisfiable. The cord.conf file contains the usual configuration options for ordered resolution. The file all.conf contains all options for the prover.

You can use more than one configuration file.

./ksp -c conf.files/ijcar-2022/T_ref.conf -c conf.files/ijcar-2022/cord_mlple_K.conf -global2local -f "~([]p ->p)"

will use both configuration files to prove that indeed the given formula is unsatisfiable in reflexive systems. The option "global2local" sets the transformation to that given in [3] and local reasoning is applied. The following

./ksp -global2local -c conf.files/ijcar-2022/T_ref.conf -c conf.files/ijcar-2022/cord_ple_ires_K.conf  -f "~([]p ->p)"

will use the calculus given in [2] for the same formula.


Options in the configuration file are overridden by those in the command line.

3 - REFERENCES

[1] Nalon, C., Hustadt, U., and Dixon, C. A Modal-Layered Resolution Calculus for K. In Proceedings of Automated Reasoning with Analytic Tableaux and Related Methods - 24th International Conference, TABLEAUX 2015, Wroclaw, Poland, September 21-24, 2015. de Nivelle, H. (editor). Lecture Notes in Computer Science, 9323, pages 185--200. Springer, 2015. DOI: 10.1007/978-3-319-24312-2_13

[2] Nalon, C. and Dixon, C. Clausal Resolution for Normal Modal Logics. Journal of Algorithms, Volume 62, Issues 3-4, July-October 2007, Pages 117-134.

[3]  Papacchini, F., Nalon, C., Hustadt, U., and Dixon, C. Efficient Local Reductions to Basic Modal Logic. in the Proceedings of the 28th International Conference on Automated Deduction (CADE-28). Platzer, A. and Sutcliffe, G. (editors). Lecture Notes in Artificial Intelligence 12699, pages 76-92, 2021. Springer. DOI: 10.1007/978-3-030-79876-5_5. Open Access.


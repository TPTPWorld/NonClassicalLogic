% START OF SYSTEM OUTPUT
% SZS status Success for MoralConflict2MML.p
%%% This output was generated by embedproblem, version 1.7.16 (library version 1.8).
%%% Generated on Wed Aug 30 09:50:42 EDT 2023
%%% using 'modal_old' embedding, version 1.5.7.
%%% Logic specification used:
%%% tff(logic_spec, logic, ($$modal_old) == ([($domains) == ($constant),($designation) == ($rigid),($terms) == ($local),($modalities) == ($modal_system_D)])).

% SZS output start ListOfTHF for MoralConflict2MML.p
%Parameter '$terms' currently unsupported; this will probably coincide with global terms.
thf(mworld,type,
    mworld: $tType ).

thf(mindex,type,
    mindex: $tType ).

thf(mrel_type,type,
    mrel: mindex > mworld > mworld > $o ).

thf('#deontic_type',type,
    '#deontic': mindex ).

thf('#alethic_type',type,
    '#alethic': mindex ).

thf(mglobal_type,type,
    mglobal: ( mworld > $o ) > $o ).

thf(mglobal_def,definition,
    ( mglobal
    = ( ^ [Phi: mworld > $o] :
        ! [W: mworld] : ( Phi @ W ) ) ) ).

thf(mnot_type,type,
    mnot: ( mworld > $o ) > mworld > $o ).

thf(mand_type,type,
    mand: ( mworld > $o ) > ( mworld > $o ) > mworld > $o ).

thf(mor_type,type,
    mor: ( mworld > $o ) > ( mworld > $o ) > mworld > $o ).

thf(mimplies_type,type,
    mimplies: ( mworld > $o ) > ( mworld > $o ) > mworld > $o ).

thf(mequiv_type,type,
    mequiv: ( mworld > $o ) > ( mworld > $o ) > mworld > $o ).

thf(mnot_def,definition,
    ( mnot
    = ( ^ [A: mworld > $o,W: mworld] :
          ~ ( A @ W ) ) ) ).

thf(mand_def,definition,
    ( mand
    = ( ^ [A: mworld > $o,B: mworld > $o,W: mworld] :
          ( ( A @ W )
          & ( B @ W ) ) ) ) ).

thf(mor_def,definition,
    ( mor
    = ( ^ [A: mworld > $o,B: mworld > $o,W: mworld] :
          ( ( A @ W )
          | ( B @ W ) ) ) ) ).

thf(mimplies_def,definition,
    ( mimplies
    = ( ^ [A: mworld > $o,B: mworld > $o,W: mworld] :
          ( ( A @ W )
         => ( B @ W ) ) ) ) ).

thf(mequiv_def,definition,
    ( mequiv
    = ( ^ [A: mworld > $o,B: mworld > $o,W: mworld] :
          ( ( A @ W )
        <=> ( B @ W ) ) ) ) ).

thf(mbox_type,type,
    mbox: mindex > ( mworld > $o ) > mworld > $o ).

thf(mbox_def,definition,
    ( mbox
    = ( ^ [R: mindex,Phi: mworld > $o,W: mworld] :
        ! [V: mworld] :
          ( ( mrel @ R @ W @ V )
         => ( Phi @ V ) ) ) ) ).

thf(mdia_type,type,
    mdia: mindex > ( mworld > $o ) > mworld > $o ).

thf(mdia_def,definition,
    ( mdia
    = ( ^ [R: mindex,Phi: mworld > $o,W: mworld] :
        ? [V: mworld] :
          ( ( mrel @ R @ W @ V )
          & ( Phi @ V ) ) ) ) ).

thf('mrel_#deontic_serial',axiom,
    ! [W: mworld] :
    ? [V: mworld] : ( mrel @ '#deontic' @ W @ V ) ).

thf('mrel_#alethic_serial',axiom,
    ! [W: mworld] :
    ? [V: mworld] : ( mrel @ '#alethic' @ W @ V ) ).

thf(mforall_fun_l__mworld_do__r__type,type,
    mforall_fun_l__mworld_do__r_: ( ( mworld > $o ) > mworld > $o ) > mworld > $o ).

thf(mforall_fun_l__mworld_do__r__def,definition,
    ( mforall_fun_l__mworld_do__r_
    = ( ^ [A: ( mworld > $o ) > mworld > $o,W: mworld] :
        ! [X: mworld > $o] : ( A @ X @ W ) ) ) ).

thf(mexists_fun_l__mworld_do__r__type,type,
    mexists_fun_l__mworld_do__r_: ( ( mworld > $o ) > mworld > $o ) > mworld > $o ).

thf(mexists_fun_l__mworld_do__r__def,definition,
    ( mexists_fun_l__mworld_do__r_
    = ( ^ [A: ( mworld > $o ) > mworld > $o,W: mworld] :
        ? [X: mworld > $o] : ( A @ X @ W ) ) ) ).

%----Conflict when you're obliged to do A and B, but it's not possible to do so
thf(moral_conflict,axiom,
    ( mglobal
    @ ( mforall_fun_l__mworld_do__r_
      @ ^ [A: mworld > $o] :
          ( mforall_fun_l__mworld_do__r_
          @ ^ [B: mworld > $o] : ( mand @ ( mbox @ '#deontic' @ A ) @ ( mand @ ( mbox @ '#deontic' @ B ) @ ( mnot @ ( mdia @ '#alethic' @ ( mand @ A @ B ) ) ) ) ) ) ) ) ).

%----Actions are obliged
thf(nm,axiom,
    ( mglobal
    @ ( mforall_fun_l__mworld_do__r_
      @ ^ [A: mworld > $o] :
          ( mforall_fun_l__mworld_do__r_
          @ ^ [B: mworld > $o] : ( mimplies @ ( mbox @ '#alethic' @ ( mimplies @ A @ B ) ) @ ( mimplies @ ( mbox @ '#deontic' @ A ) @ ( mbox @ '#deontic' @ B ) ) ) ) ) ) ).

%----Negated obligation
thf(d,axiom,
    ( mglobal
    @ ( mforall_fun_l__mworld_do__r_
      @ ^ [A: mworld > $o] : ( mimplies @ ( mbox @ '#deontic' @ A ) @ ( mnot @ ( mbox @ '#deontic' @ ( mnot @ A ) ) ) ) ) ) ).

% SZS output end ListOfTHF for MoralConflict2MML.p

% END OF SYSTEM OUTPUT
% RESULT: MoralConflict2MML - NTFinCTF---1.7.16 says Success - CPU = 1.31 WC = 0.89 
% OUTPUT: MoralConflict2MML - NTFinCTF---1.7.16 says Assurance - CPU = 1.31 WC = 0.89 

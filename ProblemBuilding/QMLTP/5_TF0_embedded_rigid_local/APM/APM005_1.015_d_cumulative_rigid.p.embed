%%% This output was generated by embedproblem, version 1.8.4 (library version 1.8).
%%% Generated on Tue Feb 13 18:04:04 CET 2024
%%% using '$modal' embedding, version 2.2.2.
%%% Logic specification used:
%%% tff(d_cumulative_rigid, logic, ($modal) == ([($designation) == ($rigid),($domains) == ($cumulative),($modalities) == ($modal_system_D),($terms) == ($local)])).
%%% Transformation parameters: SILENT

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Meta-logical definitions of the embedding %%
tff('$world_type', type, '$world': $tType).
tff('$local_world_decl', type, '$local_world': '$world').
tff('$accessible_world_decl', type, '$accessible_world': (('$world' * '$world') > $o)).
tff(mrel_serial, axiom, (! [W:'$world']: ((? [V:'$world']: ('$accessible_world'(W,V)))))).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Converted user type declarations %%%%%%%%%%%
tff(d_decl, type, d: $i).
tff(n_decl, type, n: $i).
tff(o_decl, type, o: $i).
tff(h_decl, type, h: (('$world' * $i) > $o)).
tff(closed_decl, type, closed: (('$world' * $i) > $o)).
tff(combo_decl, type, combo: (('$world' * $i * $i) > $o)).
tff(open_decl, type, open: (('$world' * $i) > $o)).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional meta-logical definitions %%%%%%%%
tff('$exists_in_world_$i_decl', type, '$exists_in_world_$i': (('$world' * $i) > $o)).
tff('$exists_in_world_$i_cumul', axiom, (! [W:'$world',V:'$world',X:$i]: ((('$exists_in_world_$i'(W,X) & '$accessible_world'(W,V)) => '$exists_in_world_$i'(V,X))))).
tff('$exists_in_world_$i_nonempty', axiom, (! [W:'$world']: ((? [X:$i]: ('$exists_in_world_$i'(W,X)))))).
tff('$exists_in_world_d_mono', axiom, (! [W:'$world']: ('$exists_in_world_$i'(W,d)))).
tff('$exists_in_world_n_mono', axiom, (! [W:'$world']: ('$exists_in_world_$i'(W,n)))).
tff('$exists_in_world_o_mono', axiom, (! [W:'$world']: ('$exists_in_world_$i'(W,o)))).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Converted problem %%%%%%%%%%%%%%%%%%%%%%%%%%
tff(ax1, axiom, (! [W:'$world']: (('$accessible_world'('$local_world',W) => (! [S:$i,V:$i]: ((('$exists_in_world_$i'(W,S) & '$exists_in_world_$i'(W,V)) => (? [O:$i]: (('$exists_in_world_$i'(W,O) & ((! [W0:'$world']: (('$accessible_world'(W,W0) => ((closed(W0,S) & (combo(W0,S,V) & h(W0,O))) => (! [W1:'$world']: (('$accessible_world'(W0,W1) => open(W1,S)))))))) & (! [W0:'$world']: (('$accessible_world'(W,W0) => ((closed(W0,S) & (~ (combo(W0,S,V)) & h(W0,o))) => (! [W1:'$world']: (('$accessible_world'(W0,W1) => closed(W1,S))))))))))))))))))).
tff(ax2, axiom, (! [W:'$world']: (('$accessible_world'('$local_world',W) => closed(W,d))))).
tff(ax3, axiom, (! [W:'$world']: (('$accessible_world'('$local_world',W) => (combo(W,d,n) | ~ (combo(W,d,n))))))).
tff(ax4, axiom, (! [W:'$world']: (('$accessible_world'('$local_world',W) => (! [S:$i]: (('$exists_in_world_$i'(W,S) => ~ ((open(W,S) & closed(W,S)))))))))).
tff(ax5, axiom, (? [V:$i]: (('$exists_in_world_$i'('$local_world',V) & (! [W:'$world']: (('$accessible_world'('$local_world',W) => combo(W,d,V)))))))).
tff(con, conjecture, (! [W:'$world']: (('$accessible_world'('$local_world',W) => (? [V:$i,O:$i]: ((('$exists_in_world_$i'(W,V) & '$exists_in_world_$i'(W,O)) & ((! [W0:'$world']: (('$accessible_world'(W,W0) => (combo(W0,d,V) & h(W0,O))))) => (! [W0:'$world']: (('$accessible_world'(W,W0) => open(W0,d)))))))))))).

%------------------------------------------------------------------------------
% File     : NTF001^1 : TPTP v8.1.0. Released v8.1.0.
% Domain   : TBA
% Problem  : TBA
% Version  : [BP13] axioms.
% English  : 

% Refs     : [RO12]  Raths & Otten (2012), The QMLTP Problem Library for Fi
%          : [BP13]  Benzmueller & Paulson (2013), Quantified Multimodal Lo
%          : [Ste22] Steen (2022), An Extensible Logic Embedding Tool for L
% Source   : [TPTP]
% Names    : GSV011+1 [QMLTP]

% Status   : Theorem 
% Rating   : ? v8.1.0
% Syntax   : Number of formulae    :   67 (  12 unt;  37 typ;  10 def)
%            Number of atoms       :   84 (  10 equ;   0 cnn)
%            Maximal formula atoms :    7 (   2 avg)
%            Number of connectives :  179 (   1   ~;   1   |;   4   &; 168   @)
%                                         (   1 <=>;   4  =>;   0  <=;   0 <~>)
%            Maximal formula depth :   14 (   5 avg)
%            Number of types       :    3 (   1 usr)
%            Number of type conns  :   94 (  94   >;   0   *;   0   +;   0  <<)
%            Number of symbols     :   37 (  36 usr;   7 con; 0-4 aty)
%            Number of variables   :   34 (  24   ^   7   !;   3   ?;  34   :)
% SPC      : TH0_THM_EQU_NAR

% Comments : This output was generated by embedproblem, version 1.7.1 (library
%            version 1.3). Generated on Thu Apr 28 13:18:18 EDT 2022 using
%            'modal' embedding, version 1.5.2. Logic specification used:
%            $modal == [$constants == $rigid,$quantification == $varying,
%            $modalities == $modal_system_S4].
%------------------------------------------------------------------------------
thf(mworld,type,
    mworld: $tType ).

thf(mrel_type,type,
    mrel: mworld > mworld > $o ).

thf(mactual_type,type,
    mactual: mworld ).

thf(mlocal_type,type,
    mlocal: ( mworld > $o ) > $o ).

thf(mlocal_def,definition,
    ( mlocal
    = ( ^ [Phi: mworld > $o] : ( Phi @ mactual ) ) ) ).

thf(mnot_type,type,
    mnot: ( mworld > $o ) > mworld > $o ).

thf(mand_type,type,
    mand: ( mworld > $o ) > ( mworld > $o ) > mworld > $o ).

thf(mor_type,type,
    mor: ( mworld > $o ) > ( mworld > $o ) > mworld > $o ).

thf(mimplies_type,type,
    mimplies: ( mworld > $o ) > ( mworld > $o ) > mworld > $o ).

thf(mequiv_type,type,
    mequiv: ( mworld > $o ) > ( mworld > $o ) > mworld > $o ).

thf(mnot_def,definition,
    ( mnot
    = ( ^ [A: mworld > $o,W: mworld] :
          ~ ( A @ W ) ) ) ).

thf(mand_def,definition,
    ( mand
    = ( ^ [A: mworld > $o,B: mworld > $o,W: mworld] :
          ( ( A @ W )
          & ( B @ W ) ) ) ) ).

thf(mor_def,definition,
    ( mor
    = ( ^ [A: mworld > $o,B: mworld > $o,W: mworld] :
          ( ( A @ W )
          | ( B @ W ) ) ) ) ).

thf(mimplies_def,definition,
    ( mimplies
    = ( ^ [A: mworld > $o,B: mworld > $o,W: mworld] :
          ( ( A @ W )
         => ( B @ W ) ) ) ) ).

thf(mequiv_def,definition,
    ( mequiv
    = ( ^ [A: mworld > $o,B: mworld > $o,W: mworld] :
          ( ( A @ W )
        <=> ( B @ W ) ) ) ) ).

thf(mbox_type,type,
    mbox: ( mworld > $o ) > mworld > $o ).

thf(mbox_def,definition,
    ( mbox
    = ( ^ [Phi: mworld > $o,W: mworld] :
        ! [V: mworld] :
          ( ( mrel @ W @ V )
         => ( Phi @ V ) ) ) ) ).

thf(mdia_type,type,
    mdia: ( mworld > $o ) > mworld > $o ).

thf(mdia_def,definition,
    ( mdia
    = ( ^ [Phi: mworld > $o,W: mworld] :
        ? [V: mworld] :
          ( ( mrel @ W @ V )
          & ( Phi @ V ) ) ) ) ).

thf(mrel_reflexive,axiom,
    ! [W: mworld] : ( mrel @ W @ W ) ).

thf(mrel_transitive,axiom,
    ! [W: mworld,V: mworld,U: mworld] :
      ( ( ( mrel @ W @ V )
        & ( mrel @ V @ U ) )
     => ( mrel @ W @ U ) ) ).

thf(eiw_di_type,type,
    eiw_di: $i > mworld > $o ).

thf(eiw_di_nonempty,axiom,
    ! [W: mworld] :
    ? [X: $i] : ( eiw_di @ X @ W ) ).

thf(mforall_di_type,type,
    mforall_di: ( $i > mworld > $o ) > mworld > $o ).

thf(mforall_di_def,definition,
    ( mforall_di
    = ( ^ [A: $i > mworld > $o,W: mworld] :
        ! [X: $i] :
          ( ( eiw_di @ X @ W )
         => ( A @ X @ W ) ) ) ) ).

thf(mexists_di_type,type,
    mexists_di: ( $i > mworld > $o ) > mworld > $o ).

thf(mexists_di_def,definition,
    ( mexists_di
    = ( ^ [A: $i > mworld > $o,W: mworld] :
        ? [X: $i] :
          ( ( eiw_di @ X @ W )
          & ( A @ X @ W ) ) ) ) ).

thf(an_a_nonce_decl,type,
    an_a_nonce: $i ).

thf(at_decl,type,
    at: $i ).

thf(bt_decl,type,
    bt: $i ).

thf(a_decl,type,
    a: $i ).

thf(b_decl,type,
    b: $i ).

thf(t_decl,type,
    t: $i ).

thf(a_holds_decl,type,
    a_holds: $i > mworld > $o ).

thf(t_holds_decl,type,
    t_holds: $i > mworld > $o ).

thf(party_of_protocol_decl,type,
    party_of_protocol: $i > mworld > $o ).

thf(a_stored_decl,type,
    a_stored: $i > mworld > $o ).

thf(fresh_to_b_decl,type,
    fresh_to_b: $i > mworld > $o ).

thf(b_stored_decl,type,
    b_stored: $i > mworld > $o ).

thf(b_holds_decl,type,
    b_holds: $i > mworld > $o ).

thf(message_decl,type,
    message: $i > mworld > $o ).

thf(generate_b_nonce_decl,type,
    generate_b_nonce: $i > $i ).

thf(quadruple_decl,type,
    quadruple: $i > $i > $i > $i > $i ).

thf(triple_decl,type,
    triple: $i > $i > $i > $i ).

thf(generate_key_decl,type,
    generate_key: $i > $i ).

thf(encrypt_decl,type,
    encrypt: $i > $i > $i ).

thf(generate_expiration_time_decl,type,
    generate_expiration_time: $i > $i ).

thf(sent_decl,type,
    sent: $i > $i > $i > $i ).

thf(key_decl,type,
    key: $i > $i > $i ).

thf(pair_decl,type,
    pair: $i > $i > $i ).

thf(a_holds_key_at_for_t,axiom,
    mlocal @ ( mbox @ ( a_holds @ ( key @ at @ t ) ) ) ).

thf(a_is_party_of_protocol,axiom,
    mlocal @ ( mbox @ ( party_of_protocol @ a ) ) ).

thf(a_sent_message_i_to_b,axiom,
    mlocal @ ( mbox @ ( message @ ( sent @ a @ b @ ( pair @ a @ an_a_nonce ) ) ) ) ).

thf(a_stored_message_i,axiom,
    mlocal @ ( mbox @ ( a_stored @ ( pair @ b @ an_a_nonce ) ) ) ).

thf(b_hold_key_bt_for_t,axiom,
    mlocal @ ( mbox @ ( b_holds @ ( key @ bt @ t ) ) ) ).

thf(b_is_party_of_protocol,axiom,
    mlocal @ ( mbox @ ( party_of_protocol @ b ) ) ).

thf(nonce_a_is_fresh_to_b,axiom,
    mlocal @ ( mbox @ ( fresh_to_b @ an_a_nonce ) ) ).

thf(t_holds_key_at_for_a,axiom,
    mlocal @ ( mbox @ ( t_holds @ ( key @ at @ a ) ) ) ).

thf(t_holds_key_bt_for_b,axiom,
    mlocal @ ( mbox @ ( t_holds @ ( key @ bt @ b ) ) ) ).

thf(t_is_party_of_protocol,axiom,
    mlocal @ ( mbox @ ( party_of_protocol @ t ) ) ).

thf(ax1,axiom,
    mlocal @ ( mbox @ ( b_holds @ ( key @ ( generate_key @ an_a_nonce ) @ a ) ) ) ).

thf(ax2,axiom,
    mlocal @ ( mbox @ ( message @ ( sent @ a @ b @ ( pair @ ( encrypt @ ( triple @ a @ ( generate_key @ an_a_nonce ) @ ( generate_expiration_time @ an_a_nonce ) ) @ bt ) @ ( encrypt @ ( generate_b_nonce @ an_a_nonce ) @ ( generate_key @ an_a_nonce ) ) ) ) ) ) ).

thf(ax3,axiom,
    mlocal @ ( mbox @ ( a_holds @ ( key @ ( generate_key @ an_a_nonce ) @ b ) ) ) ).

thf(ax4,axiom,
    mlocal @ ( mbox @ ( message @ ( sent @ t @ a @ ( triple @ ( encrypt @ ( quadruple @ b @ an_a_nonce @ ( generate_key @ an_a_nonce ) @ ( generate_expiration_time @ an_a_nonce ) ) @ at ) @ ( encrypt @ ( triple @ a @ ( generate_key @ an_a_nonce ) @ ( generate_expiration_time @ an_a_nonce ) ) @ bt ) @ ( generate_b_nonce @ an_a_nonce ) ) ) ) ) ).

thf(ax5,axiom,
    mlocal @ ( mbox @ ( message @ ( sent @ b @ t @ ( triple @ b @ ( generate_b_nonce @ an_a_nonce ) @ ( encrypt @ ( triple @ a @ an_a_nonce @ ( generate_expiration_time @ an_a_nonce ) ) @ bt ) ) ) ) ) ).

thf(ax6,axiom,
    mlocal @ ( mbox @ ( b_stored @ ( pair @ a @ an_a_nonce ) ) ) ).

thf(co1,conjecture,
    ( mlocal
    @ ( mexists_di
      @ ^ [U: $i] : ( mand @ ( mbox @ ( a_holds @ ( key @ U @ b ) ) ) @ ( mbox @ ( b_holds @ ( key @ U @ a ) ) ) ) ) ) ).

%------------------------------------------------------------------------------
